Reassess the grouping options in Spark, expanding the comparison to include all major methods from both `RelationalGroupedDataset` (from `groupBy`) and `KeyValueGroupedDataset` (from `groupByKey`).

Specifically, you're asking for a comparative table focusing on three criteria for each method: its main use case, its role in Structured Streaming, and its support for built-in windowing and watermarking.

Here is a comprehensive table comparing these methods. 

---

### ## Comparison of Spark Grouping and Aggregation Methods

| Method                                 | Source Class               | Main Use Case ðŸŽ¯                                                                                                                                                         | Structured Streaming Usage                                                                                                          | Windowing & Watermarking Support                                                                                                                                                |
| -------------------------------------- | -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`agg()`**<br/>(incl. `count`, `sum`) | `RelationalGroupedDataset` | Performing standard, declarative, SQL-like aggregations. **Highly optimized** due to Spark's ability to pre-aggregate before shuffling.                                  | **Fully Supported**. This is the standard way to perform simple stateful aggregations, like running counts or totals.               | **Yes, fully integrated**. This is the primary method used with `window()` and `withWatermark()` for time-based aggregations. Spark manages all state for the windows.          |
| **`reduceGroups()`**                   | `KeyValueGroupedDataset`   | **Batch only**. Reducing all elements in a group to a single element of the **same type** using a custom binary function.<br>                                            | **Not Supported**. This method cannot be used on a streaming `Dataset`.                                                             | No                                                                                                                                                                              |
| **`mapGroups()`**                      | `KeyValueGroupedDataset`   | **Batch only**. Applying a custom function to each group to produce **exactly one** result, which can be a different type.                                               | **Not Supported**. This method cannot be used on a streaming `Dataset`.                                                             | No                                                                                                                                                                              |
| **`flatMapGroups()`**                  | `KeyValueGroupedDataset`   | **Batch only**. The most flexible batch method. Applying a custom function to each group to produce **zero, one, or many** results.                                      | **Not Supported**. Its streaming equivalent is `flatMapGroupsWithState`.                                                            | No                                                                                                                                                                              |
| **`mapGroupsWithState()`**             | `KeyValueGroupedDataset`   | **Streaming only**. Applying custom stateful logic across batches. Must produce **exactly one** output for each group that receives new data.                            | **Yes**, this is its exclusive purpose. A fundamental tool for stateful streaming before `flatMapGroupsWithState` became preferred. | **No (directly)**. It doesn't chain with `.window()`. Windowing logic must be manually implemented inside the function, and state cleanup is handled via `GroupState` timeouts. |
| **`flatMapGroupsWithState()`**         | `KeyValueGroupedDataset`   | **Streaming only**. The most advanced and flexible stateful operation. Produces **zero, one, or many** outputs, ideal for complex logic like alerting or sessionization. | **Yes**, this is its exclusive purpose and the modern, recommended approach for custom stateful streaming.                          | **No (directly)**. Same as its `map` counterpart. You implement time-based logic and state cleanup manually using event-time fields and state timeouts within your function.    |